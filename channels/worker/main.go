package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

func main() {
	// любой контекст, в данном примере лучше бы подошел WithCancel, но для простоты использован WithTimeout
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()

	tn := time.Now() // для замера времени работы программы

	dataCh := getDataChannel(ctx) // канал с данными для обработки(функция их генерирует для демонстрации работы)

	wg := &sync.WaitGroup{} // для синхронизации и завершения всех горутин

	// Паттерн worker упрощенный (упрощенный, потому что одновременно работают N-воркеров и часть может простаивать просто так
	// Есть метод при котором воркер сам будет приходить за работой если она есть
	// Смысл в экономии ресурсов, зачем запускать лишние горутины, особенно если их тысячи.
	// Но данный пример не про это. Здесь мы точно определяем количество наших горутин и заставляем их всех работать

	for i := 0; i < 10; i++ { // 10 воркеров для примера
		wg.Add(1)                                                                                 // синхронизируем wg
		go worker(ctx, dataCh, make(chan int) /*упрощение так как с каналом out нет работы*/, wg) // запускаем горутину
	}

	wg.Wait() // ждем завершения всех горутин

	fmt.Println(time.Since(tn).String()) // измеряем время работы
}

// Также в данном примере в функцию worker можно было бы подать out chan по классическому паттерну, чтобы обрабатывать данные и писать их в выходной канал
func worker(ctx context.Context, ch <-chan int, _ chan int, wg *sync.WaitGroup) {
	defer wg.Done() // "завершаем" горутину

	// недостаток что воркер может зависнуть при чтении из канала и проверка таймаута не сработает
	for el := range ch { // идем по каналу и читаем оттуда значения
		select {
		case <-ctx.Done(): // после каждой итерации по каналу проверяем имеет ли смысл идти дальше или контекст отменился
			fmt.Println("context done")
			return
		default:
			fmt.Printf("read el %d\n", el)
			// outChan < el

			// если функция обработки долгая, можно поставить еще одну проверку отмены контекста внутри после некоторых итераций

			// sleep стоит, чтобы показать, что функция обработки значения из канала может быть долгой
			// worker будет какое-то время занят обработкой одного значения,
			// но при этом не забываем, что несколько воркеров читают асинхронно с одного канала
			//time.Sleep(1 * time.Second)
		}
	}
}

// тут возвр канал с данными который надо будет обрабатывать впоследствии
func getDataChannel(ctx context.Context) <-chan int {
	out := make(chan int)

	// важно запустить горутину чтобы не блокироваться
	go func() {
		defer close(out) // по завершению функции надо закрыть канал, либо успеем записать все данные либо выйдем по таймауту

		for i := 0; i < 1000; i++ { // в данном примере данные в канал пишутся синхронно по очереди
			select {
			case <-ctx.Done(): // проверяем завершение
				fmt.Println("timeout") // не удалось записать все данные за отведенное время
				return
			case out <- i: // пишем в канал
				fmt.Println("sent", i)
			}
		}
	}()

	return out // сразу возвращаем канал чтобы клиент не ждал записи, а начал сразу обрабатывать этот канал и читать из него данные
}
